## 지연 실행
- 모든 람다의 핵심은 '지연 실행'이며,'지연 실행'의 이유는 다음과 같다.
1) 별도의 스레드에서 코드 실행
2) 코드를 여러번 실행
3) 알고리즘에서 코드를 적절한 시점에 실행
4) 어떤 일이 발생했을 때 코드 실행
5) 필요할 때만 코드 실행

## 함수형 인터페이스 선택
- 함수형 인터페이스는 특정 의미가 없는 '모든 함수'를 받고자 하는 상황이 많으며 이 용도로 사용할 수 있는 여러가지 제네릭 함수 타입이 있다.
1) Runnable
2) Supplier<T>
3) Consumer<T>
4) BiConsumer<T>
5) Function<T, R>
6) BiFunction<T, U, R>
7) UnaryOperator<T>
8) BinaryOperator<T>
9) Predicate<T>
10) BiPredicate<T,U>

## 함수 리턴
- 함수형 프로그래밍 언어에서는 함수가 일차 구성원이다. 따라서, 인자와 리턴값이 함수일 수 있다.

## 합성
- 단일 인자를 받는 함수는 한 값을 다른 값으로 변환한다. 
- 이러한 변환이 두가지 있다면, 하나를 수행한 다음 다른 하나를 수행하는 일 또한 변환이다.

## 지연
- 라이브러리에 모든 연산을 쌓아둔 후 결합하는 방식으로 '합성'연산을 대체할 수 있다.
- 지연 처리를 할 때는 API 에서 수행할 작업을 쌓아두는 중간 연산(intermediate operation)과 결과를 주는 최종 연산(terminal operation)을 구별해야 한다.

## 연산 병렬화
- 연산을 함수형 인터페이스로 표현할 때, 호출자는 세부 처리에 관한 제어를 놓는다.
- 예를 들어 이미지 처리에서는 이미지를 여러 조각으로 분리해서 각 조각들을 독립적으로 처리할 수 있다.

## 예외 다루기
- 람다를 받는 메서드를 작성할 때 에는 람다 표현식을 실행할 때 발생할 수 있는 예외를 처리하고 보고할 방법을 생각해봐야 한다.
- 람다 표현식에서 예외를 던지면, 해당 예외는 호출자에게 전파된다.
- 병렬 처리와 같이 별도의 스레드에서 발생한 예외를 처리하기 위해선, Consumer<Throwable>을 전달해 처리할 수 있다.

## 람다와 제네릭
- 일반적으로 람다는 제네릭 타입과 잘 어울려 동작한다.
- 하지만, 타입 소거(type erasure)의 불행한 결과 중 하나로 Collection<T>와 Stream<T>의 toArray() 메서드는 runtime 에 제네릭 배열을 생성할 수 없다. (ex T[] result = new T[n])
- 람다를 사용하면 다음과 같이 생성자를 전달해 새로운 배열을 생성한다. 
```
String[] result = words.toArray(String[]::new);
```