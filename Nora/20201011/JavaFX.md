*javaFx
- 자바를 이용해 리치 클라이언트 애플리케이션을 작성할 때 권장되는 사용자 인터페이스 툴킷이다.
- 모든 버전의 오라클 자바 플랫폼에 번들되어있다.
- 리치 클라이언트 사용자 인터페이스를 개발한다면 스윙에서 javaFx로 옮겨가는 방법을 보게 될 것이다.

* 핵심내용
- 씬 그래프는 다른 노드를 포함할 수도 있는 노드들로 구성된다.
- 씬은 스테이지, 즉 최상위 윈도우, 애플릿 서피스 또는 전체화면 위에 표시된다.
- 버튼 같은 일부 컨트롤은 이벤트를 발생시키지만, 대부분의 javaFx 이벤트는 프로퍼티 변경으로 발생한다.
- javaFx 프로퍼티는 변경 및 무효화 이벤트를 발생시킨다.
- 프로퍼티를 또 다른 프로퍼티에 바인드하면 다른 프로퍼티가 변경될 때 해당 프로퍼티도 업데이트된다.
- javaFx는 스윙의 레이아웃 관리자와 유사하게 동작하는 레이아웃 페인을 사용한다.
- FXML 마크업 언어를 이용해 레이아웃을 지정할 수 있다.
- 애플리케이션의 외관을 변경하는 데 css를 이용할 수 있다.
- 애니메이션과 특수 효과를 구현하기 쉽다.
- javaFx는 자체적으로 차트, 내장 웹킷 브라우저, 미디어 플레이어 같은 몇 가지 고급 컨트롤을 제공한다.

* 01 자바 GUI 프로그래밍의 간략한 역사
- 비지니스 어플리케이션은 (수많은 버튼, 슬라이더, 텍스트 필드를 포함하며 서버와 통신하는 프로그램인) '중량 클라이언트'로 구현했다.
- 당시에는 중량 클라이언트를 더 이전 시기부터 내려오던 '덤 터미널' 애플리케이션보다 훨씬 나은 것으로 여겼다.

- 자바 1.0은 그래픽 사용자 인터페이스 툴킷인 AWT를 포함했는데, 크로스 플랫폼 지원이라는 두드러진 특징이 있다.
- AWT는 다양한 운영체제의 네이티브 버튼, 슬라이더, 텍스트 필드 등을 위한 공통 프로그래밍 인터페이스를 제공한다는 숭고한 발상으로 만들어졌다.

- AWT 다음으로 스윙이 등장했다. 스윙의 핵심 발상은 네이티브 위젯을 사용하지 않고 자체적으로 그리는 것이다.
이 방식으로 사용자 인터페이스는 모든 플랫폼에서 룩앤필을 유지하게 되었다. 그러나 속도가 느려 사용자들의 불평이 많았고
네이티브 컨트롤을 전혀 사용하지 않으면서도 더 화려한 사용자 인터페이스를 생성하기 위해 플래시를 점점 더 사용하게 되었다.

- 2007년에 썬 마이크로시스템즈는 javaFx라는 새로운 기술을 플래시의 경쟁자로 소개했다. javaFx는 자바 VM위에서 실행하지만
javaFX 스크립트라는 자체적인 프로그래밍 언어를 갖추고 있었다. 2011년에 오라클은 별도의 프로그래밍 언어를 요구하지 않고
자바 API로 된 새로운 버전인 javaFx 2.0을 발표했다. 자바 7 업데이트 6부터는 JDK와 JRE에 javaFX 2.2가 번들되었다.
자바 8에 실리는 버전은 javaFX 8이라고 부른다.

- javaFX가 생겨난 동기가 된 화려한 효과가 아닌 버튼, 슬라이더, 텍스트 필드를 포함하는 지루한 비즈니스 애플리케이션에 초점을 둔다.

* 02 Hello, javaFx!
- 스윙에서처럼 레이블(label)을 사용한다.
Label message = new Label("Hello, JavaFx!");
- 눈에 거슬리는 접두어 J가 없다는 점에 주목! 스윙에서는 레이블 컨트롤의 이름이 AWT Label과 구분하기 위해 JLabel이다.

- 다음과 같이 폰트 사이즈를 증가시킨다.
message.setFont(new Font(200));

- JavaFx에서는 보여주고 싶은 모든 것을 씬에 넣는다. 씬에서 액터 즉 컨트롤과 도형을 장식하고 애니메이션을 줄 수 있다.

- 씬은 반드시 스테이즈 안에 있어야 한다. 스테이지는 프로그램을 데스크톱에서 실행하는 경우 최상위 윈도우를, 애플릿에서 실행하는 경우에는 사각 영역을 의미한다.
- 스테이지는 Application클래스의 서브클래스에서 반드시 오버라이드해야 하는 start 메서드의 파라미터로 전달된다.

- 예제)
public class HelloWorld extends Application{
    public void start(Stage stage){
        Label message = new Label("Hello, javaFx!");
        message.setFont(new Font(200));
        stage.setScene(new Scene(message));
        stage.setTitle("Hello");
        stage.show();
    }
}
- javaFx 애플리케이션을 실행하는 데는 main 메서드가 필요하지 않다.

* 03 이벤트 처리
- 그래픽 사용자 인터페이스는 이벤트로 구동한다. 사용자는 버튼을 클릭하고 슬라이더를 조절하는 식으로 사용한다.
 사용자가 이러한 액션을 수행하면 UI가 반응하며 자체적으로 업데이트한다.
- 스윙에서는 버튼 클릭 시에 통지를 받을 수 있도록 이벤트 처리기를 버튼에 추가한다. 람다 표현식은 이 작업을 아주 간단하게 만들어준다.
Button red = new Button("Red");
red.setOnAction(event->message.setTextFill(Color.RED));

- 대부분의 JavaFx 컨트롤에서는 이벤트 처리가 이와 다르다. value라는 javaFx 프로퍼티를 포함하며, 프로퍼티 값이 변할 때 이벤트를 내보낸다.
slider.valueProperty().addListener(property -> message.setFont(new Font(slider.getValue()));
- JavaFx에서는 프로퍼트의 이벤트를 수신하는 일이 아주 흔하다. 예를 들어 사용자가 텍스트 필드에 텍스트를 입력할 때 사용자 인터페으스의 일부를 
변경하려는 경우 text 프로퍼티에 리스너를 추가한다.
- 버튼은 특수한 경우이다. 버튼 클릭은 버튼의 프로퍼티를 변경하지 않는다.

* 04 JavaFx 프로퍼티
- 프로퍼티는 읽거나 쓸 수 있는 클래스의 속성이다. 보통은 프로퍼티를 필드로 뒷받침하며 게터와 세터는 단순히 해당 필드를 읽고 쓴다.
- 자바빈즈 명세에서는 게터/세터 쌍으로 부터 프로퍼트를 추정해야 한다고 설명하고 있다.
예를 들어, String getText()와 setText(String newValue) 메서드를 포함하는 클래스는 text 프로퍼티가 있는 걸로 간주한다.
java beans 패키지의 Introspector와 BeanInfo 클래스를 이용하면 클래스의 모든 프로퍼티를 나열할 수 있다.
- 자바빈즈 명세는 또한 객체에서 세터가 호출되었을 때 프로퍼티 변경 이벤트를 내보내는 바운드 프로퍼티를 정의하고 있다.
- JavaFx는 이 부분을 사용하지 않는다. 대신 JavaFx 프로퍼티는 게터와 세터 외에 property 인터페이스를 구현하는 객체를 리턴하는
세번째 메서드를 포함한다. 
- 예를 들어, JavaFx text 프로퍼티는 Property<String> textProperty()라는 메서드를 포함한다. 프로퍼티 객체에 리스너를 추가할 수 있다.
바로 이 점이 자바빈즈와 다르다. JavaFx는 빈이 아니라 프로퍼티 객체가 통지를 보낸다.
이러한 변화가 나타난 이유는 자바빈즈 프로퍼티를 구현하려면 리스너를 추가 및 삭제하고 리스너에 이벤트를 보내는 전투적인 코드가 필요하다.
JavaFx에서는 이 작업을 모두 해주는 라이브러리 클래스가 존재하기 때문에 훨씬 간편하다.

- 예제
public class Greeting{
    private StringProperty text = new SimpleStringProperty("");
    public final StringProperty textProperty(){return text;}
    public final void setText(String newValue){text.set(newValue);}
    public final String getText(){return text.get();}
}
- JavaFx로 구현할 때도 몇몇 상투적인 코드가 필요하며, 유감스럽게도 자바에서 해당 코드를 자동으로 생성하는 방법은 없다.
- 프로퍼티 게터와 세터를 final로 선언하는 것이 필수는 아니지만 JavaFx 설계자들은 이를 권장한다.

- 프로퍼티에 붙일 수 있는 리스너의 종류는 두 가지다.
1. ChangeListener : 프로퍼티 값이 변경되었을 때 통지
2. InvalidationListener : 값이 변경되엇을 수 있을 때 호출

* 05 바인딩
- JavaFx 프로퍼티이 존재이유는 바인딩(다른 프로퍼티가 변경될 때 자동으로 특정 프로퍼티를 업데이트 하는 것)이라는 개념이다.
- 예제
billing.textProperty().bind(shipping.textProperty());
billing.textProperty().bindBidirectional(shipping.textProperty());
- 바인딩을 취소하려면 unbind 또는 unbindBidirectional을 호출한다.

* 06 레이아웃
- 그래픽 사용자 인터페이스가 다수의 컨트롤을 포함하는 경우 이들을 기능적이면서도 매력적인 방법으로 화면에 배치해야 한다.
- 레이아웃을 얻는 방법이 세가지가 있다.
1. 디자인 도구를 이용한다. 도구의 사용자는 컨트롤을 나타내는 이미지를 디자인 뷰로 끌어다 놓고 각각 배치하고, 크기를 조절하고 속성을 설정한다.
하지만 이 접근법은 요소들의 크기가 변할 때 문제가 될 수 있다.
2. 설정 메서드에서 사용자 인터페이스 컨트롤을 특정 위치에 추가하는 코드를 작성함으로써 프로그래밍을 통해 레이아웃을 만들 수 있다.
스윙에서는 이 방법으로 레이아웃 관리자 객체를 이용해 레이아웃을 만든다.
3. 선언형 언어로 레이아웃을 지정하는 것이다. 예를 들어, 웹 페이지는 HTML과 CSS를 이용해 레이아웃을 만든다. 유사하게 안드로이드에는
레이아웃을 지정하는데 사용하는 XML 언어가 있다.

- 프로그래밍을 통한 레이아웃은 스윙과 아주 유사하다. 하지만 임의의 패널에 추가되는 레이아웃 관리자 대신 페인을 사용한다.
- 페인이란 레이아웃 정책을 갖춘 컨테이너를 말한다. 

- JavaFx 레이아웃
1. HBox,VBox : 자식을 가로,세로로 배치한다.
2. GridPane : 스윙의 GridBagLayout과 유사하게 자식들을 테이블 형태 그리드에 배치한다.
3. TitlePane : 스윙의 GridLayout과 유사하게 자식들을 그리드에 배치하고 모든 자식에게 같은 크기를 부여한다.
4. BorderPane : 스윙의 BorderLayout과 유사하게 North,East,South,West,Center영역을 제공한다.
5. FlowPane : 스윙의 FlowLayout과 유사하게 행 안에 자식들을 흘려서 배치하며, 충분한 공간이 없을 때는 새로운 행을 만든다.
6. AnchorPane : 자식들을 절대 위치로 배치하거나 페인의 경계를 기준으로 상대적으로 배치할 수 있다. SceneBuilder레이아웃 도구의 기본값이다.
7. StackPane : 자식들을 서로 쌓아서 배치한다. 색상을 입힌 사각형 위에 버튼을 배치할 때 처럼 컴포넌트들을 장식하는데 유용하다.

* 07 FXML
- JavaFx에서 레이아웃을 기술하는 데 사용하는 마크업 언어를 FXML이라고 한다.
- FXML은 JavaFx에서 요구하는 것 이상으로 개념이 흥미롭고 구현이 상당히 일반적이다.

* 08 CSS
- JavaFx는 CSS를 이용해 사용자 인터페이스의 외관을 변경할 수 있게 해준다. 보통은 CSS를 이용하는 방법이 FXML 속성을 전달하거나 
자바 메소드를 호출하는 방법보다 훨씬 편리하다.

* 09 애니메이션과 특수효과
- JavaFX가 생겨날 당시 특수 효과가 엄청나게 유행했다. 새도우, 블러, 움직임을 만들어내기 쉽게 해준다.
- JavaFX는 일정 시간 동안 노드의 프로퍼티를 변하게 하는 다양한 트랜지션을 정의한다.
- FadeTransition은 노드의 불투명도를 변경한다.
- RotateTransition은 노드의 rotate 프로퍼티를 변경한다.
- ParallelTransition과 SequentialTransition 콤비네이터를 이용하면 트랜지션을 합성해 병렬 또는 순차적으로 수행할 수 있다.

* 10 화려한 컨트롤
- JavaFX는 스윙과 마찬가지로 콤보박스, 탭 페인, 테이블 지원은 물론이고 스윙에서 전혀 볼 수 없던 데이트 픽커, 어코디언 같은 사용자 인터페이스 컨트롤도 지원한다.                                                                                                                                                                                                                    