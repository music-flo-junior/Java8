* 핵심내용
- 람다 표현식은 파라미터가 있는 코드 블록이다.
- 코드 블록을 나중에 실행하고자 할 떄 람다 표현식을 사용한다.
- 람다 표현식을 함수형 인터페이스로 변환할 수 있다.
- 람다 표현식은 자신을 감싸고 있는 유효 범위에 속한 사실상 final 변수를 접근할 수 있다.
- 메서드 래퍼런스와 생성자 래퍼런스는 각각 메서드와 생성자를 호출없이 참조한다.
- 이제 인터페이스에 실제 구현을 제공하는 디폴트 메서드와 정적메서드를 추가할 수 있다.
- 여러 인터페이스의 디폴트 메서드들 사이의 충돌을 해결해야 한다.

* 01 왜 람다인가?
- '람다 표현식' : 나중에 한 번 이상 실행할 수 있도록 전달할 수 있는 코드블록 (파라미터가 있는 표현식)

* 02 람다 표현식 문법
- (String first, String second) -> Integer.compare(first.length(),second.length())
- 단순한 코드 블록으로, 변수들의 명세와 함께 코드에 전달.
- 메서드 파라미터와 마찬가지 방식으로 람다 파라미터 에 애너테이션이나 final 수정자를 붙일 수 있다. 
예) final String name / @NonNull String name
- 람다 표현식의 결과 타입은 지정하지 않는다. 결과 타입은 항상 문맥으로부터 추정된다.
- 람다 표현식이 어떤 경우에는 값을 리턴하고, 다른 경우에는 리턴하지 않는 것은 규칙에 어긋난다.
예) (int x) -> { if (x>=0) return 1;}

* 03 함수형 인터페이스
- 자바에는 Runnable, Comparator 등 코드 블록을 캡슐화하는 수많은 기존 인터페이스가 있다.
람다는 이런 기존 인터페이스와 호환된다.
- 단일추상메서드를 갖춘 인터페이스의 객체를 기대할 때 람다 표현식을 사용할 수 있다.
이런 인터페이스를 함수형 인터페이스라고 한다.
- Arrays.sort(words,(first, second) -> Integer.compare(first.length(),second.length()));
내부적으로, Arrays.sort 메서드는 Comparator<String>을 구현하는 어떤 클래스의 객체를 받는다.
전달받은 객체의 compare 메서드를 호출하면 람다 표현식의 몸체를 실행한다.
이러한 객체와 클래스의 관리는 순전히 구현체의 몫이며, 전통적으로 사용해온 이너 클래스 방식보다 훨씬 효율적이다.
- 함수형 인터페이스로 변환이 자바에서 람다 표현식을 이용해 할 수 있는 유일한 일이다.
- 람다 표현식이 함수형 인터페이스의 인스턴스로 변환될 때 검사 예외가 문제가 된다는 점을 유의하기 바란다.
람다 표현식의 몸체에서 검사 예외를 던질 수 있는 경우, 해당 예외가 대상 인터페이스의 추상 메서드에 선언되어 있어야한다.
예) 다음 형식은 오류이다.
Runnable sleeper = () -> {System.out.println("zzz"); Thread.sleep(1000);};
// 오류: Thread.sleep은 검사 예외인 InterruptedException을 던질 수 있다.
Runnable.run 메서드는 예외를 던질 수 없기 때문에 위의 대입은 잘못된 것이다.

오류를 바로 잡는 2가지 방법 
1. 람다 표현식의 몸체에서 예외를 잡는다.
2. 해당 예외를 던질 수 있는 단일 추상 메서드를 갖춘 인터페이스에 람다를 대입한다.
예를 들어, Callable 인터페이스의 call 메서드는 어떤 예외든 던질 수 있다.
따라서 return null 문장을 추가한다면 위의 람다 표현식을 Callable<Void>에 대입할 수 있다.

* 04 메서드 레퍼런스
- button.setOnAction(event -> System.out.println(event));
간결하게 println 메서드만 전달할 수 있다면 더 좋을 것이다.
button.setOnAction(System.out::println); 
System.out::prinrtln 표현식이 바로 메서드 레퍼런스다.
- :: 연산자는 객체 또는 클래스와 메서드 이름을 구분하여 다음 세 가지 주요 경우가 있다.
1. object::instanceMethod   예) System.out::println
2. Class::staticMethod      예) Math::pow
3. Class::instanceMethod    예) String::compareToIgnoreCase(x,y)

* 05 생성자 레퍼런스
- 메서드의 이름이 new라는 점을 제외하면 메서드 레퍼런스와 유사하다.
- 예를 들어 Button::new는 버튼 생성자를 가리키는 레퍼런스다.

* 06 변수 유효 범위
- 종종 람다 표현식에서 해당 표현식을 감싸고 있는 메서드나 클래스에 있는 변수에 접근하고 싶을 때가 있다.
람다 표현식이 자유 변수를 포함하고 이를 자료구조에서 저장하는 방식을 캡쳐했다고 말한다.
- 람다 표현식은 세가지로 구성 
> 1. 코드블록 2. 파라미터 3. 자유변수(파라미터도 아니고 코드 내부에도 정의되지 않은 변수)의 값
- 람다 표현식에서는 값이 변하지 않는 변수만 참조할 수 있다.
- 람다 표현식의 몸체는 중첩블록과 동일한 유효범위를 가진다. 따라서 중첩 블록과 동일한 이름 충돌 및 가리기 규칙이 적용된다.
- 지역 변수와 이름이 같은 파라미터나 다른 지역변수를 람다 내부에 선언하는 것은 규칙에 어긋난다. 




