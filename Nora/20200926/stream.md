* 핵심내용
- 반복자(lterator)는 특정 순회 전략을 내포하므로 효율적인 동시 실행을 방해한다.
- 컬렉션, 배열, 발생기, 반복자로부터 스트림을 생성할 수 있다.
- 요소를 선택하는데 filter를 사용하고, 요소를 변환하는데 map을 사용한다.
- 스트림을 변환하는 다른 연산으로는 limit, distinict, sorted가 있다.
- 스트림에서 결과를 얻으려면 count, max, min, finFirst 또는 findAny 같은 리덕션 연산자를 사용한다.
이들 메서드 중 몇몇은 Optional 값을 리턴한다.
- Optional 타입은 null 값을 다루는 안전한 대안을 목적으로 만들어졌다. Optional 타입을 안전하게 사용하려면 
ifPresent와 orElse메서드를 이용한다.
- 스트림 결과들을 컬렉션, 배열, 문자열 또는 맵으로 모을 수 있다.
- Collectors 클래스의 groupingBy와 PartitioningBy 메서드는 스트림의 내용을 그룹으로 분할하고 각 그룹
의 겨로가를 얻을 수 있게 해준다.
- 기본 타입인 int, long, double용으로 특화된 스트림이 있다.
- 병렬 스트림을 이용할 때는 부가 작용(side effect)을 반드시 피해야 하고, 순서 제약을 포기하는 방안도 고려한다.
- 스트림 라이브러리를 사용하려면 몇 가지 함수형 인터페이스와 친숙해져야 한다.

* 01 반복에서 스트림 연산으로
- 컬렉션을 처리할 때, 보통은 요소들을 순회하면서 각 요소를 대상으로 작업한다.

- 자바8의 벑크 연산(bulk operation) 
> long count = words.stream().filter(w->w.length() > 12).count();
> stream 메서드는 words 리스트의 스트림을 돌려준다.
> filter 메서드는 12글자보다 긴 단어만 담은 다른 스트림을 리턴한다.
> count 메서드는 이 스트림을 결과로 리듀스한다.

- 스트림은 데이터를 변환하고 추출할 수 있게 해주어 겉으로는 컬렉션과 유사하게 보인다. 하지만 중대한 차이점이 있다.
1. 스트림은 요소들을 보관하지 않는다. 요소들은 하부의 컬렉션에 보관되거나 필요할 때 생성된다.
2. 스트림 연산은 원본을 변경하지 않는다. 대신 결과를 담은 새로운 스트림을 반환한다.
3. 스트림 연산은 가능하면 지연 처리된다. 지연 처리란 결과가 필요하기 전에는 실행되지 않음을 의미한다.
예를 들어, 긴 단어를 모두 세는 대신 처음 5개 긴 단어를 요청하면, filter 메서드는 5번 째 일치 후 필터링을 중단한다.
결과적으로 심지어 무한 스트림도 만들 수 있다.

- 스트림은 쉽게 병렬화할 수 있다.
> long count = words.parallelStream().filter(w->w.length() > 12).count();
> 단순히 stream을 parallelStream으로 변경하는 것만으로 스트림 라이브러리가 필터링과 카운팅을 병렬로 수행하게 할 수 있다.

- 스트림은 '어떻게가 아니라 무엇을'원칙을 따른다. 따라서 스트림은 무엇을 어떻게 해야하는지 정의한다.

- 스트림을 이용해 작업할 때는 연산들의 파이프라인을 세단계로 설정한다.
1. 스트림을 생성한다.
2. 초기 스트림을 다른 스트림으로 변환하는 중간연산들을 하나 이상의 단계로 지정한다.
3. 결과를 산출하기 위해 최종연산을 적용한다. 이 연산은 앞선 지연 연산들의 실행을 강제한다. 이후로는 해당 스트림을 더는 사용할 수 없다.
> 앞선 예제에서는 stream 또는 parallelStream 메서드로 스트림을 생성한다. filter 메서드로 스트림을 변환하고, count는 최종 연산이다.

- 스트림 연산들은 요소를 대상으로 실행할 때 스트림에서 호출된 순서로 실행되지 않는다. 앞선 예제에서는 count가 호출되기 전에는 
아무 일도 일어나지 않는다. count 메서드가 첫 번째 요소를 요청하면, filter메서드가 길이 > 12인 요소를 찾을 때 까지 요소들을 요청하기 시작한다.

* 02 스트림 생성
